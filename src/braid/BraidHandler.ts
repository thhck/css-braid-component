import { getLoggerFor } from '../logging/LogUtil'
import type { HttpHandlerInput } from '../server/HttpHandler';
import { HttpHandler } from '../server/HttpHandler';
import type { HttpResponse } from '../server/HttpResponse';
import type { HttpRequest } from '../server/HttpRequest';
import { BadRequestHttpError } from '../util/errors/BadRequestHttpError';
import { InternalServerError } from '../util/errors/InternalServerError';
import { ResourceStore } from '../storage/ResourceStore'

// Chat Data: initial chat messages.
const resources: { [key: string]: Array<{ text: string }> } = {
  '/chat': [
    { text: 'Hello!' },
    { text: 'This is a post!' },
    { text: 'This is a post-modern!' }
  ]
};

interface BraidHttpRequest extends HttpRequest {
  subscribe: boolean;
  patches: any;
}

interface BraidHttpResponse extends HttpResponse {
  sendUpdate: (update: { version: string[], body: string }) => void;
  startSubscription: any;
}


interface BraidHttpHandlerInput {
  request: BraidHttpRequest;
  response: BraidHttpResponse;
}

// Function to return the current version based on the number of chat messages.
const chat_version = (): string[] => [resources['/chat'].length.toString()];

// Subscription storage: keys are generated by subscription_hash.
const subscriptions: { [key: string]: BraidHttpResponse } = {};

// Generate a subscription key using the request's peer header and url.
const subscription_hash = (req: HttpRequest): string =>
  JSON.stringify([req.headers.peer, req.url]);



/**
 * HTTP handler to provide a /chat braid endpoint to css.
 */

export class BraidHttpHandler extends HttpHandler {
  protected readonly logger = getLoggerFor(this);
  private readonly resourceStore: ResourceStore;

  constructor(resourceStore: ResourceStore) {
    super();
    this.resourceStore = resourceStore;
  }

  public async handle({ request, response }: BraidHttpHandlerInput): Promise<void> {
    // TODO get name, email etc from profile
 
 
    try {
      if (request.method === 'GET') {
        // Log the GET request and peer
        this.logger.info(`GET for peer ${request.headers.peer}`);

        // If the request is a subscription, start it and store the response.
        if (request.subscribe) {
          response.startSubscription({
            onClose: () => {
              delete subscriptions[subscription_hash(request)];
              this.logger.info(`Subscription closed for hash ${subscription_hash(request)}`);
            }
          });
          subscriptions[subscription_hash(request)] = response;
          this.logger.info(`Subscribing at hash ${subscription_hash(request)}`);
        } else {
          response.statusCode = 200;
        }

        // Send the current chat data as the update payload.
        response.sendUpdate({
          version: chat_version(),
          body: JSON.stringify(resources['/chat'])
        });

        // End the response if this was not a subscription request.
        if (!request.subscribe) {
          response.end();
        }
      } else if (request.method === 'PUT') {
        // Process PATCH updates from PUT requests.
        const patches = await request.patches(); // Assumes braidjs adds .patches() to the request.

        // Validate that the request contains exactly one patch with the expected properties.
        if (patches.length !== 1) {
          throw new BadRequestHttpError('Expected one patch');
        }
        if (patches[0].range !== '[-0:-0]') {
          throw new BadRequestHttpError("Patch range must be '[-0:-0]'");
        }
        if (patches[0].unit !== 'json') {
          throw new BadRequestHttpError("Patch unit must be 'json'");
        }

        // Add the new chat message to the resources.
        const newMessage = JSON.parse(patches[0].content_text);
        resources['/chat'].push(newMessage);

        // Broadcast the update to all subscribers for this URL, excluding the sender.
        for (const key in subscriptions) {
          try {
            const [peer, url] = JSON.parse(key);
            if (url === request.url && peer !== request.headers.peer) {
              subscriptions[key].sendUpdate({
                version: chat_version(),
                // patches
                body: JSON.stringify(resources['/chat'])
              });
            }
          } catch (err) {
            this.logger.error('Error parsing subscription key:' + err);
          }
        }

        response.statusCode = 200;
        response.end();
      } else {
        // For any other HTTP methods, respond with Method Not Allowed.
        response.statusCode = 405;
        response.end();

      }
    } catch (err) {
      this.logger.error('Error handling request:' + err);
      throw new InternalServerError('Error handling request:' + err)
    }
  }
}

