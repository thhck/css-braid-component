import type { ETagHandler } from '../../storage/conditions/ETagHandler';
import type { ResourceStore } from '../../storage/ResourceStore';
import { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';
import { assertReadConditions } from '../../util/ResourceUtil';
import { OkResponseDescription } from '../output/response/OkResponseDescription';
import type { ResponseDescription } from '../output/response/ResponseDescription';
import type { OperationHandlerInput } from './OperationHandler';
import { OperationHandler } from './OperationHandler';
import { getLoggerFor } from '../../logging/LogUtil';
import { readableToQuads, readJsonStream } from '../../util/StreamUtil';
import { ReadStream } from 'node:fs';
import { Guarded, guardStream } from '../../util/GuardedStream';
import { PassThrough, Readable } from 'node:stream';
import { BraidSubscriptionStore } from '../../braid/BraidSubscriptionStore';

// Subscription storage: keys are generated by subscription_hash
export const subscriptions: { [key: string]: any } = {};

// Generate a subscription key using the request's peer header and url
const subscription_hash = (req: any): string =>
  // '123' // TODO: use storage
  JSON.stringify([req.headers.peer, req.url]);

var resources = [
      {text: 'Hello!'},
      {text: 'This is a post!'},
      {text: 'This is a post-modern!'}
  ]


/**
 * Handles GET {@link Operation}s.
 * Calls the getRepresentation function from a {@link ResourceStore}.
 */
export class GetOperationHandler extends OperationHandler {
  protected readonly logger = getLoggerFor(this);
  private readonly store: ResourceStore;
  private readonly braidStore: BraidSubscriptionStore;
  private readonly eTagHandler: ETagHandler;

  public constructor(store: ResourceStore, braidStore: BraidSubscriptionStore, eTagHandler: ETagHandler) {
    super();
    this.store = store;
    this.braidStore = braidStore
    this.eTagHandler = eTagHandler;
  }

  public async canHandle(input: OperationHandlerInput): Promise<void> {
    const { operation } = input;
    if (operation.method !== 'GET') {
      throw new NotImplementedHttpError('This handler only supports GET operations');
    }
  }

  public async handle(input: OperationHandlerInput): Promise<ResponseDescription> {
    const { operation, request, response } = input as OperationHandlerInput & { request: any, response: any };
    const body = await this.store.getRepresentation(operation.target, operation.preferences, operation.conditions);

    // Check whether the cached representation is still valid or it is necessary to send a new representation
    assertReadConditions(body, this.eTagHandler, operation.conditions);

    // If the request is a subscription, start it and store the response
    if (request.subscribe) {
      response.startSubscription({
        onClose: async () => {

          delete subscriptions[subscription_hash(request)];
          // await this.braidStore.delete(subscription_hash(request))
          this.logger.info(`Subscription closed for hash ${subscription_hash(request)}`);
        }
      });
      subscriptions[subscription_hash(request)] = response;
      // await this.braidStore.set(subscription_hash(request), response);
      this.logger.info(`Subscribing at hash ${subscription_hash(request)}`);
    } else {
      // it was in the example but doesn't seems to be useful
      // response.statusCode = 200;
    }
    const [dataStream1, dataStream2] = teeStream(body.data);
    const isBraidRequest = (request: any) => request.headers.peer ? true : false;
    // Send the current data as the update payload
    if (isBraidRequest(request) && response.sendUpdate) {
      // const eTag = this.eTagHandler.getETag(body.metadata);
      // updateVersion = eTag
      let updateVersion = Math.random().toString().slice(2,8)

      
      
      let content;
      
      // Clone the stream before reading
      
      // Ensure stream is in flowing mode and collect data
      dataStream1.resume();
      content = await readableToBuffer(dataStream1);
      content = content.toString();
      
      response.sendUpdate({
        version: [updateVersion],
        body: JSON.stringify([{text: content}])

      });
    }

    // Properly handle response ending based on request type
    if (!request.subscribe) {
      // response.end();
      return new OkResponseDescription(body.metadata, dataStream2);
    }else{
      // I need to keep the HTTP connection open
      // let's create a stream and not close it
      // idk if this the right way, but no other idea for now
      const stream = guardStream(new PassThrough())
      // this.streamMap.add(topic, stream);
      stream.on('error', () => {
        this.logger.warn(">>>>>>>>> STREAM ERROR")
      });
      stream.on('close', () => {        
        this.logger.warn(">>>>>>>>> STREAM CLOSED")
      });      
      return new OkResponseDescription(body.metadata, stream)
    }
    
  }

}
/** Helper to clone a stream into two identical streams */
function teeStream(stream: Guarded<Readable>): [Guarded<Readable>,Guarded<Readable>] {
  const stream1 = guardStream(new PassThrough());
  const stream2 = guardStream(new PassThrough());
  stream.pipe(stream1);
  stream.pipe(stream2);
  return [stream1, stream2];
}

/** Helper to collect stream data into a Buffer */
export async function readableToBuffer(stream: Guarded<Readable>): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    stream.on('data', (chunk:any) => chunks.push(chunk));
    stream.on('end', () => resolve(Buffer.concat(chunks)));
    stream.on('error', reject);
  });
}

